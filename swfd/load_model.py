# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/02_load_model.ipynb (unless otherwise specified).

__all__ = ['NORMALIZE', 'loadModel', 'formatdate', 'getCsvData', 'getNameRunFolders', 'singlePrediction',
           'ensemblePrediction', 'ensembleMeanVar', 'modelPrediction']

# Cell
import torch
import yaml
from fastcore.script import *
from .resources import *
import os
import csv
import numpy as np
import matplotlib.pyplot as plt
import datetime
import pandas as pd

NORMALIZE=707.6

# Cell
def loadModel(pathrun):
    pathyaml=str(pathrun)+"config.yaml"
    stacktype=[]
    pathpth=str(pathrun)+"models/best.pth"
    config=yaml.safe_load(open(str(pathyaml)))
    for i in range(0,config["nb_stacks"]["value"]):
        stacktype.append(NBeatsNet.GENERIC_BLOCK)
    device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
    model = NBeatsNet(
                  device=device,
                  stack_types=stacktype,
                  nb_blocks_per_stack=config["nb_blocks_per_stack"]["value"],
                  forecast_length=config["horizon"]["value"],
                  backcast_length=config["lookback"]["value"],
                  thetas_dim=(7, 8, 7, 8, 7, 8, 7, 8, 7, 8, 7, 8, 7, 8, 7, 8, 7, 8, 7, 8, 7, 8, 7, 8, 7, 8, 7, 8, 7, 8),
                  share_weights_in_stack=False,
                  hidden_layer_units=64
                  #,nb_harmonics=None
                  )
    checkpoint = torch.load(pathpth,map_location=device)
    model.load_state_dict(checkpoint['model_state_dict'])
    model.eval()
    return model


# Cell
def formatdate(date):
    return date.strftime("%Y-%m-%d")

# Cell
#startdate = yesterday
def getCsvData(lookback,startdate=(datetime.datetime.now()-datetime.timedelta(1)) ):
    pathfoldercsv=getInfo("csvdirectory")
    csvname="sfuData.csv"
    datalist=[]
    date=formatdate(startdate)
    start=False
    try:
        with open(str(pathfoldercsv)+str(csvname)) as csv_file:
            forecastcount=0
            for row in list(csv.reader(csv_file, delimiter=',')):
                if(date==row[0]):
                    start=True
                if(forecastcount<lookback and start):
                    datalist=np.append(datalist,float(row[1]))
                    forecastcount=forecastcount+1


    finally:
        csv_file.close()
    return datalist


# Cell
def getNameRunFolders(horizon,runshorizonfolder):
    runshorizon_directories=runshorizonfolder+"ensembleH"+str(horizon)
    runs_directories=[] #runshorizon_directories
    directories = os.listdir(str(runshorizon_directories))
    for i in directories:
        pathrun=runshorizon_directories+"/"+str(i)+"/"
        runs_directories.append(pathrun)

    return runs_directories


# Cell
# Startdate!=gendate stardate=daybefore(gendate)
def singlePrediction(filepath,startdate):
    net=loadModel(str(filepath))
    lookback=net.backcast_length
    data=getCsvData(lookback,startdate)#,net.forecast_length) data=getCsvData(lookback)
    #print("datos predict: ",data)
    row = torch.Tensor([data[::-1]/NORMALIZE])#comprobar esto
    backcast,forecast = net(row)
    preds_tensor=(forecast.detach().numpy())*NORMALIZE
    return preds_tensor[0].reshape(1,net.forecast_length)


# Cell
def ensemblePrediction(horizon,startdate):
    prediction=np.empty((0,horizon))
    folderpath=getInfo("pthdirectory")
    runspath=getNameRunFolders(horizon,folderpath)
    for run in runspath:
        prediction=np.append(prediction,singlePrediction(run,startdate),axis=0)
    return prediction

# Cell
def ensembleMeanVar(prediction):
    meanlist=[]
    stdlist=[]
    for row in prediction.T:
        meanlist.append(row.mean())
        stdlist.append(row.std())
    return np.array(meanlist),np.array(stdlist)

# Cell
def modelPrediction(horizon,startdate):
    prediction=ensemblePrediction(horizon,startdate)

    mean,std=ensembleMeanVar(prediction)
    return prediction,mean,std
