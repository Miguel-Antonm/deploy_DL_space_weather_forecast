# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/02_load_model.ipynb (unless otherwise specified).

__all__ = ['loadModel', 'getcsvdata', 'getnamerunfolders', 'singleprediction', 'ensembleprediction', 'ensembleMeanVar',
           'modelprediction']

# Cell
import torch
import yaml
from fastcore.script import *
from .recursos.model import *
import csv
import numpy as np
import os
import matplotlib.pyplot as plt
from .web_scraping import *

# Cell
def loadModel(pathrun):
    pathyaml=str(pathrun)+"config.yaml"
    pathpth=str(pathrun)+"best.pth"
    config=yaml.safe_load(open(str(pathyaml)))
    device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
    model = NBeatsNet(device=device,stack_types=(NBeatsNet.GENERIC_BLOCK, NBeatsNet.GENERIC_BLOCK),
                  nb_blocks_per_stack=config["nb_blocks_per_stack"]["value"],
                  thetas_dims=config["thetas_dims"]["value"],
                  hidden_layer_units=config["hidden_layer_units"]["value"],
                  forecast_length=config["horizon"]["value"],backcast_length=config["lookback"]["value"])
    checkpoint = torch.load(pathpth,map_location=device)
    model.load_state_dict(checkpoint['model_state_dict'])
    model.eval()
    return model


# Cell
def getcsvdata(lookback):
    pathfoldercsv=getInfo("csvdirectory") #Obtiene del txt el path del csv
    csvname="sfuData.csv" #Siempre se llamara as√≠
    datalist=[]
    try:
        with open(str(pathfoldercsv)+str(csvname)) as csv_file:
            forecastcount=0
            for row in reversed(list(csv.reader(csv_file, delimiter=','))):
                if(forecastcount<lookback):
                    datalist=np.append(datalist,float(row[1]))
                    forecastcount=forecastcount+1

    finally:
        csv_file.close()
    return datalist


# Cell
def getnamerunfolders(horizon,runshorizonfolder):
    runshorizonfolder=runshorizonfolder+"ensembleH"+str(horizon)
    pathfolderruns=[]
    contenido = os.listdir(str(runshorizonfolder))
    for i in contenido:
        pathrun=runshorizonfolder+"/"+str(i)+"/"
        pathfolderruns.append(pathrun)

    return pathfolderruns


# Cell
def singleprediction(filepath,normalize):
    net=loadModel(str(filepath))
    lookback=net.backcast_length
    data=getcsvdata(lookback)
    row = torch.Tensor([data/normalize])
    backcast,forecast = net(row)
    preds_tensor=(forecast.detach().numpy())*normalize
    return preds_tensor[0]


# Cell
def ensembleprediction(horizon,normalize):
    prediction=[]
    folderpath=getInfo("pthdirectory")
    runspath=getnamerunfolders(horizon,folderpath)
    for run in runspath:
        prediction.append(singleprediction(run,normalize))
    return prediction

# Cell
def ensembleMeanVar(prediction):
    matrix = []
    invertiblematrix=[]
    meanlist=[]
    stdlist=[]
    for i in range (0,len(prediction[0])):#Horizon que sera la longitud de la prediccion invidual en una run
        matrix = []
        for j in range(0,len(prediction)):#num de runs que se han hecho, es el numero de prediciones hechas
            matrix.append(prediction[j][i])
        invertiblematrix.append(matrix)

    for element in invertiblematrix:
        nparray=np.array(element,float)
        meanlist.append(nparray.mean())
        stdlist.append(nparray.std())

    return np.array(meanlist),np.array(stdlist)

# Cell
def modelprediction(forecast,normal):#Parametro normal esta para hacer pruebas
    #normalize=getMaxValueSfu()
    normalize=normal#Funcion web_scraping getMaxValueSfu(), funciona, pero parra ahorrar tiempo en las pruebas

    prediction=ensembleprediction(forecast,normalize)

    mean,std=ensembleMeanVar(prediction)
    return prediction,mean,std
