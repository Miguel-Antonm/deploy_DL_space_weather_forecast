# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/02_load_model.ipynb (unless otherwise specified).

__all__ = ['loadModel', 'getcsvdata', 'forecastModel', 'runprediction', 'sweepprediction', 'sweepMeanVar', 'predecir']

# Cell
import torch
import yaml
from fastcore.script import *
from .recursos.model import *
import csv
import numpy as np
import os
import matplotlib.pyplot as plt
from .web_scraping import *

# Cell
def loadModel(pathrun):
    pathyaml=str(pathrun)+"config.yaml"
    pathpth=str(pathrun)+"best.pth"
    config=yaml.safe_load(open(str(pathyaml)))
    device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
    model = NBeatsNet(device=device,stack_types=(NBeatsNet.GENERIC_BLOCK, NBeatsNet.GENERIC_BLOCK),
                  nb_blocks_per_stack=config["nb_blocks_per_stack"]["value"],
                  thetas_dims=config["thetas_dims"]["value"],
                  hidden_layer_units=config["hidden_layer_units"]["value"],
                  forecast_length=config["horizon"]["value"],backcast_length=config["lookback"]["value"])
    checkpoint = torch.load(pathpth,map_location=device)
    model.load_state_dict(checkpoint['model_state_dict'])
    model.eval()
    return model, config["lookback"]["value"]


# Cell
def getcsvdata(path,lookback):
    pathfoldercsv='/home/miguel/Escritorio/tfg_swf/csv/'
    nombredatos="2021-1-27-19sfuData.csv"
    #listadatos=np.array([])
    listadatos=[]
    try:
        with open(str(pathfoldercsv)+str(nombredatos)) as csv_file:
            forecastcount=0
            for row in reversed(list(csv.reader(csv_file, delimiter=','))):
                if(forecastcount<lookback):
                    listadatos=np.append(listadatos,float(row[1]))
                    #listadatos.append(float(row[1]))
                    forecastcount=forecastcount+1

    finally:
        csv_file.close()
    return listadatos


# Cell
def forecastModel(forecast): #Prediction
    #BUscar path de csv
    #Buscar path de la run
    pathfolderrun='/home/miguel/Escritorio/tfg_swf/csv/pth/'
    pathfoldercsv='/home/miguel/Escritorio/tfg_swf/csv/'
    pathfolderrun=pathfolderrun+"ensembleH"+str(forecast)
    pathfolderruns=[]
    contenido = os.listdir(pathfolderrun)
    for i in contenido:
        pathrun=pathfolderrun+"/"+str(i)+"/"
        pathfolderruns.append(pathrun)

    return pathfolderruns

# Cell
def runprediction(path,normalize):
    net,lookback=loadModel(str(path))
    data=getcsvdata("",lookback)
    row = torch.Tensor([data/normalize])
    backcast,forecast = net(row)
    preds_tensor=(forecast.detach().numpy())*938.6
    return preds_tensor[0]
#runprediction('/home/miguel/Escritorio/tfg_swf/csv/pth/ensembleH7/sweep_run_16/',938.6)

# Cell
def sweepprediction(path,normalize):
    prediction=[]
    runspath=forecastModel(7)
    for run in runspath:
        prediction.append(runprediction(run,normalize))
    return prediction
#prediction=sweepprediction('/home/miguel/Escritorio/tfg_swf/csv/pth/ensembleH7/',938.6)

# Cell
def sweepMeanVar(prediction):
    matriz = []
    matrizmadre=[]
    meanlist=[]
    varlist=[]
    for i in range (0,7):
        matriz = []
        for j in range(0,90):
            matriz.append(prediction[j][i])
        matrizmadre.append(matriz)
    for element in matrizmadre:
        nparray=np.array(element,float)
        print("media",nparray.mean(),"    varianza",nparray.var())
        meanlist.append(nparray.mean())
        varlist.append(nparray.var())
    return meanlist,varlist
#print(matriz)

# Cell
def predecir(forecast):
    normalize=938.6#Funcion web_scraping getMaxValueSfu(), funciona, pero parra ahorra tiempo en las pruebas
    lookback=forecast*6
    forecastlist=[]
    data=getcsvdata("",lookback)
    prediction=sweepprediction('/home/miguel/Escritorio/tfg_swf/csv/pth/ensembleH7/',938.6)
    mean,var=sweepMeanVar(prediction)
    return prediction,mean,var
